; main.a65 - sd2snes menu ROM entry point (64tass port)
; Supports warm boot (WRAM restore from SRAM) and cold boot paths.
; Emulator mode detected via MCU timeout; file browser on real hardware.

.cpu "65816"

; --- Include constants and macros ---
.include "memmap.i65"
.include "dma.i65"
.include "stack.i65"
.include "data.i65"

; =============================================
; Code starts at $C00000 (HiROM bank $C0)
; =============================================
* = $C00000
.dpage 0                 ; direct page is always $0000 (never changed)

; Reserve space for nmihook pointer (matches original layout)
.word 0               ; nmihook placeholder

; =============================================
; GAME_MAIN - Entry point from RESET
; =============================================
GAME_MAIN
  sep #$20
  .as
  .databank 0          ; DBR = $00 after RESET

  stz $4200            ; inhibit VBlank NMI
  lda #$01
  sta $420d            ; enable FastROM

  ; --- Check for warm boot (CMD_RESET issued before reset?) ---
  rep #$20
  .al
  lda #$0000
  sta MCU_CMD          ; clear MCU command register
  sta MCU_PARAM        ; clear MCU parameters
  sta MCU_PARAM+2
  lda WARM_SIGNATURE
  cmp #$fa50
  bne coldboot
  eor WARM_COMPLEMENT  ; validate: signature ^ complement must = $ffff
  inc a
  bne coldboot

  ; --- Warm boot: restore file browser state ---
  sta WARM_SIGNATURE   ; clear signature (A=0, prevents re-entry)
  sta WARM_COMPLEMENT
  lda SAVED_SP         ; restore stack pointer from before CMD_RESET
  tcs

  ; Light init: skip clear_wram, screen_on
  ; setup_gfx clears $0000-$00FF and $8000-$FFFF, then we restore
  ; the backed-up state on top to recover file browser variables.
  sep #$20
  .as
  rep #$10
  .xl
  jsr killdma
  jsr apu_ram_init
  jsr waitblank
  jsr snes_init
  jsr setup_gfx

  ; DMA restore: WRAM_BAK ($FF:2000) → WRAM ($7E:0000), 8KB
  ; Must come AFTER setup_gfx which clears $0000-$00FF.
  stz $2183            ; WRAM bank = $7E
  ldx #$0000
  stx $2181            ; WRAM address = $0000
  stz $4370            ; DMA mode: A→B, single register
  ldx #WRAM_BAK & $ffff
  stx $4372            ; source address
  lda #WRAM_BAK >> 16
  sta $4374            ; source bank
  ldx #$2000
  stx $4375            ; transfer size = 8KB
  lda #$80
  sta $4371            ; B-bus register = $2180 (WMDATA)
  sta $420b            ; trigger DMA channel 7

  jsr store_wram_routines
  jsr colortest
  jsr video_init
  jsr setup_hdma
  jsr setup_224          ; restore 224-line mode, trigger file list redraw
  jsr detect_ultra16
  jsr detect_satellaview
  lda CFG_BRIGHTNESS_LIMIT
  bne +
  lda #$0f             ; fallback to max brightness
+ sta cur_bright
  sta tgt_bright
  sta $2100            ; set brightness immediately
  plp                  ; restore processor state from caller
  rts                  ; return to code that issued CMD_RESET

  ; --- Cold boot: full initialization ---
coldboot
  sep #$20
  .as
  jsr killdma
  jsr clear_wram
  jsr apu_ram_init
  jsr snes_init
  jsr clear_vram
  jsr clear_cgram
  jsr waitblank
  jsr setup_gfx
  jsr store_wram_routines
  jsr colortest
  jsr video_init
  jsr setup_hdma

  ; --- Hardware detection + screen on + MCU detection ---
  jsr detect_ultra16
  jsr detect_satellaview
  jsr screen_on
  jsr wait_mcu_ready

  ; --- Initialize ball sprite (shared by both paths) ---
  sep #$20
  .as
  lda #100
  sta ball_x
  lda #100
  sta ball_y
  lda #2
  sta ball_vx
  lda #1
  sta ball_vy
  stz bounce_wall

  ; Check if MCU responded
  lda SNES_CMD
  cmp #$55
  bne emu_mode

  ; --- Normal MCU path: file browser ---
  jsr setup_224          ; set 224-line mode, listdisp = 18
  jsr filesel_init
  sep #$20
  .as
  lda ST_RTC_VALID
  beq +
  jsl rtc_init           ; "Please set the time" dialog
+
  jsr fileselloop        ; main file browser loop (never returns normally)
  sei
  stz $4200
  jml infloop            ; infinite loop in WRAM

  ; --- Emulator mode: no MCU, show POC display ---
emu_mode
  .databank 0
  lda #$0f
  sta cur_bright
  sta tgt_bright
  sta bright_limit
  sta $2100            ; force brightness now

  ; Patch HDMA tables for emulator mode: no logo bitmap, so switch to
  ; Mode 5 early (scanline 8 instead of 56) for text rendering in top rows.
  lda #8
  sta hdma_mode        ; mode switch table first scanline count
  sta hdma_bg1scroll   ; BG1 scroll table first scanline count
  sta hdma_bg2scroll   ; BG2 scroll table first scanline count

  jsr poc_display

  ; Wait for one guaranteed fresh NMI so the complete text is in VRAM.
  stz isr_done
- lda isr_done
  lsr
  bcc -
  stz isr_done
  ; Now safe to stop: tile DMAs ($1000×2 = ~65K cycles) exceed VBlank
  ; (~50K cycles), corrupting the first ~11 scanlines. Text is static.
  lda #1
  sta screen_dma_disable

  ; --- Initialize animation state ---
  stz anim_frame
  stz anim_speed
  stz anim_timer
  stz anim_phase
  stz anim_src_idx
  stz anim_src_idx+1
  stz anim_dst_idx
  stz anim_dst_idx+1
  stz hdma_pal_flip

  ; --- Switch data bank to $7E for WRAM variable access ---
  lda #$7e
  pha
  plb
  .databank $7e

  ; --- Emulator main loop: wait for NMI each frame ---
mainloop
  .databank $7e
- lda isr_done
  lsr
  bcc -
  stz isr_done
  jsr read_pad
  .databank $7e          ; read_pad preserves DBR
  jsr update_ball
  jsr animate_gradient
  .databank $7e          ; animate_gradient preserves DBR via phb/plb
  bra mainloop




; =============================================
; colortest - Clear color window settings
; =============================================
colortest
  .databank 0
  sep #$20
  .as
  stz $2130
  rts

; =============================================
; setup_gfx - Load fonts, palette, HDMA tables
; Requires: DBR=$00, force blank on
; =============================================
setup_gfx
  .databank 0
  sep #$20
  .as
  rep #$10
  .xl

  stz $4200            ; disable NMI during setup
  stz $420b            ; disable DMA
  stz $420c            ; disable HDMA

  ; --- Clear WRAM variable area ($7E:0000-$7E:00FF) ---
  ; clear_wram fills with $55 (sentinel), so we zero DP variables here.
  ; Warm boot restores backed-up values on top of this after setup_gfx returns.
  ldx #$0000
  stx $2181
  lda #$00
  sta $2183            ; bank $7E (bit 0 = 0)
  DMA7 $08, zero, $80, $0100  ; clear 256 bytes ($0000-$00FF)

  ; --- Clear WRAM tile buffer area ($7E:8000-$7E:FFFF) ---
  ldx #$8000
  stx $2181
  lda #$00
  sta $2183
  DMA7 $08, zero, $80, $8000

  ; --- Generate fonts in VRAM ---
  jsr genfonts

  ; --- Clear BG1 tilemap in VRAM ---
  ldx #BG1_TILE_BASE
  stx $2116
  DMA7 $09, zero, $18, $1000  ; zero fill 4096 bytes

  ; --- Clear BG2 tilemap in VRAM ---
  ldx #BG2_TILE_BASE
  stx $2116
  DMA7 $09, zero, $18, $1000

  ; --- Clear OAM tables ---
  ldx #$0000
  stx $2102
  DMA7 $08, zero, $04, $0220  ; 544 bytes OAM

  ; --- Hide sprites 1-127 (Y=$F0 = off-screen) ---
  ; After clearing OAM to zeros, all 128 sprites sit at (0,0)
  ; with tile 0. Without hiding them, 127 ghost copies of tile 0
  ; pile up in the top-left corner.
  ldx #$0002           ; OAM word address for OBJ 1 (byte 4)
  stx $2102
  ldx #127             ; 127 sprites to hide
- stz $2104            ; X = 0
  lda #$f0
  sta $2104            ; Y = $F0 (off-screen)
  stz $2104            ; tile = 0
  stz $2104            ; attr = 0
  dex
  bne -

  ; --- Load ball sprite tile to VRAM ---
  ; OBJ tiles at OAM_TILE_BASE ($6000)
  ldx #OAM_TILE_BASE
  stx $2116
  DMA7 $01, ball_tile, $18, ball_tile_end - ball_tile

  ; --- Set OBJ size and tile base ---
  ; $2101: ssnnmbbb
  ;   ss=00 (8x8 small, 16x16 large)
  ;   nnn=000 (name select)
  ;   bbb=011 (base at $6000, each increment = $2000)
  lda #$03
  sta $2101

  ; --- Load palette via DMA to CGRAM ---
  stz $2121            ; CGADD = color 0
  DMA7 $00, palette, $22, $0200  ; 512 bytes → $2122

  ; --- Set ball sprite color (white) in OBJ palette ---
  ; CGRAM writes allowed during Forced Blank, V-Blank, or H-Blank.
  ; Writing during active display produces corrupted colors.
  ; Ball uses color 15 of OBJ palette 0 = CGRAM color 143
  lda #143
  sta $2121            ; CGADD = color 143
  lda #$ff             ; white low byte (R=31, G=31 low bits)
  sta $2122
  lda #$7f             ; white high byte (G high bits, B=31)
  sta $2122

  ; --- Copy HDMA source tables from ROM to WRAM ---
  ; Use WRAM port ($2180) for destination.
  ; Palette gradient (buffer A at $0100)
  lda #hdma_pal >> 16
  ldx #hdma_pal & $ffff
  stx $2181
  sta $2183
  DMA7 $00, hdma_pal_src, $80, hdma_pal_src_end - hdma_pal_src

  ; Palette gradient (buffer B at $0300 — double-buffer copy)
  lda #hdma_pal_back >> 16
  ldx #hdma_pal_back & $ffff
  stx $2181
  sta $2183
  DMA7 $00, hdma_pal_src, $80, hdma_pal_src_end - hdma_pal_src

  ; CG address table
  lda #hdma_cg_addr >> 16
  ldx #hdma_cg_addr & $ffff
  stx $2181
  sta $2183
  DMA7 $00, hdma_cg_addr_src, $80, 227

  ; Screen mode table
  lda #hdma_mode >> 16
  ldx #hdma_mode & $ffff
  stx $2181
  sta $2183
  DMA7 $00, hdma_mode_src, $80, 5

  ; BG1 scroll table
  lda #hdma_bg1scroll >> 16
  ldx #hdma_bg1scroll & $ffff
  stx $2181
  sta $2183
  DMA7 $00, hdma_bg1scroll_src, $80, 21

  ; BG2 scroll table
  lda #hdma_bg2scroll >> 16
  ldx #hdma_bg2scroll & $ffff
  stx $2181
  sta $2183
  DMA7 $00, hdma_bg2scroll_src, $80, 13

  ; Color math table
  lda #hdma_math >> 16
  ldx #hdma_math & $ffff
  stx $2181
  sta $2183
  DMA7 $00, hdma_math_src, $80, 19

  ; Initialize window stack (empty sentinel)
  ldx #$ffff
  stx window_stack_head

  rts

; =============================================
; genfonts - Load font tiles into VRAM
; Two copies: pseudo-4bpp at $0000, 2bpp at $4000
; Uses DMA7 auto-increment trick: each trigger advances
; the source address, so a loop of triggers loads sequential
; characters with gaps in VRAM.
; Requires: DBR=$00
; =============================================
genfonts
  .databank 0
  php
  rep #$10
  .xl
  sep #$20
  .as

  ; Clear VRAM font area 1: $0000-$3FFF (pseudo-4bpp, 16KB)
  ldx #$0000
  stx $2116
  DMA7 $09, zero, $18, $4000

  ; Clear VRAM font area 2: $4000-$5FFF (2bpp, 8KB)
  ldx #$4000
  stx $2116
  DMA7 $09, zero, $18, $2000

  ; --- Load font as pseudo-4bpp at VRAM $0000 ---
  ; Each 2bpp character is 16 bytes. In pseudo-4bpp mode,
  ; each tile slot is 32 bytes ($20). We DMA 16 bytes per
  ; character, stepping VRAM address by $20 each iteration.
  sep #$10
  .xs
  rep #$20
  .al

  stz $2116            ; VRAM address = 0
  stz $2117
  ldx #$01             ; DMA mode: A→B, 2-reg (word writes)
  stx $4370
  ldx #font >> 16
  stx $4374            ; source bank
  lda #font & $ffff
  sta $4372            ; source address (auto-increments across triggers)
  lda #$0010
  sta $4375            ; transfer 16 bytes per trigger
  ldx #$18             ; B-bus = $2118 (VMDATAL)
  stx $4371

  lda #$0000
- sta $2116            ; set VRAM address for this character
  ldx #$10
  stx $4375            ; reset transfer size (consumed by each trigger)
  ldx #$80
  stx $420b            ; trigger DMA channel 7
  clc
  adc #$20             ; next tile slot (32 bytes apart in pseudo-4bpp)
  cmp #$2000
  bne -

  ; --- Load font as 2bpp at VRAM $4000 ---
  ; Same trick, but tiles are 16 bytes apart ($10 step)
  ldx #font >> 16
  stx $4374
  lda #font & $ffff
  sta $4372            ; reset source to font start

  lda #$4000
- sta $2116
  ldx #$10
  stx $4375
  ldx #$80
  stx $420b
  clc
  adc #$10             ; next tile slot (16 bytes apart in 2bpp)
  cmp #$5000
  bne -

  plp
  rts


; =============================================
; video_init - Configure BG modes, layers, brightness vars
; Sets up Mode 3 display with Mode 5 via HDMA switching
; Requires: DBR=$00
; =============================================
video_init
  .databank 0
  sep #$20
  .as
  rep #$10
  .xl

  lda #$03             ; Mode 3, 8×8 tiles (Mode 5 via HDMA)
  sta $2105

  ; BG1 tilemap at VRAM $B000, 32×64 size
  lda #$58             ; ($B000 >> 8) = $58... wait
  ora #$02             ; SC size 32×64
  sta $2107

  ; BG2 tilemap at VRAM $A000, 32×64 size
  lda #$50             ; ($A000 >> 8) = $50... wait
  ora #$02
  sta $2108

  ; Chr base: BG1=$0000, BG2=$8000
  lda #$40             ; BG2 chr at $8000 (nibble = $4)
  sta $210b

  ; Enable BG1+BG2+OBJ on main screen
  lda #$13             ; OBJ + BG1 + BG2
  sta $212c

  ; Enable BG1+BG2 on sub screen (no OBJ)
  lda #$03
  sta $212d

  ; Window 1 for color math (OBJ window)
  lda #$20
  sta $2125

  ; Cut off leftmost subscreen pixel garbage
  lda #$01
  sta $2126            ; window 1 left
  lda #$fe
  sta $2127            ; window 1 right

  ; 224-line mode
  stz $2133            ; SETINI = normal (224 lines)

  ; Color math: sub screen + fixed color
  lda #$10
  sta $2130

  ; Window mask for main/sub screens
  lda #$1f
  sta $212e
  sta $212f

  ; --- Initialize WRAM state variables ---
  ; With .databank 0, these access the WRAM mirror at $00:xxxx
  lda #29              ; bar_yl=29 → bar_y=224 → clamps to scanline 1 (off-screen)
  sta bar_yl
  stz cur_bright
  stz tgt_bright
  lda #$01
  sta fade_speed
  stz fade_count
  stz screen_dma_disable
  stz screen_dma_disable+1

  rts


; =============================================
; screen_on - Turn screen on with brightness
; In emulator mode, CFG_BRIGHTNESS_LIMIT = 0 → use $0F
; =============================================
screen_on
  .databank 0
  sep #$20
  .as
  stz $2100            ; screen on, 0% brightness
  ; Always use max brightness (emulator mode)
  lda #$0f
  sta tgt_bright
  sta bright_limit
  sta cur_bright
  sta $2100            ; set brightness immediately
  rts


; =============================================
; poc_display - Render emulator mode text
; Uses hiprint to write text to WRAM tile buffers.
; Caller must wait for NMI to DMA buffers to VRAM.
; Requires: DBR=$00
; =============================================
poc_display
  .databank 0
  sep #$20
  .as
  rep #$10
  .xl

  ; title: "S A T E L L A V I E W" at row 3, bold
  lda #3
  sta print_y
  lda #5               ; centered: (32-21)/2 ≈ 5
  sta print_x
  lda #title_str1 >> 16
  sta print_bank
  ldx #title_str1 & $ffff
  stx print_src
  lda #1               ; bold palette
  sta print_pal
  lda #32
  sta print_count
  jsr hiprint

  ; subtitle: "revival project" at row 5
  lda #5
  sta print_y
  lda #9               ; centered: (32-15)/2 ≈ 8
  sta print_x
  lda #title_str2 >> 16
  sta print_bank
  ldx #title_str2 & $ffff
  stx print_src
  stz print_pal        ; normal palette
  lda #32
  sta print_count
  jsr hiprint

  ; byline: "by DavidAF" at row 6
  lda #6
  sta print_y
  lda #11              ; centered: (32-10)/2 = 11
  sta print_x
  lda #title_str3 >> 16
  sta print_bank
  ldx #title_str3 & $ffff
  stx print_src
  stz print_pal        ; normal palette
  lda #32
  sta print_count
  jsr hiprint

  ; line 1: "WE HAVE BREACHED THE PERIMITER" at row 10
  lda #10
  sta print_y
  lda #3
  sta print_x
  lda #emu_str1 >> 16
  sta print_bank
  ldx #emu_str1 & $ffff
  stx print_src
  lda #1               ; bold palette
  sta print_pal
  lda #32
  sta print_count
  jsr hiprint

  ; line 2: "No MCU detected" at row 12
  lda #12
  sta print_y
  lda #4
  sta print_x
  lda #emu_str2 >> 16
  sta print_bank
  ldx #emu_str2 & $ffff
  stx print_src
  stz print_pal
  lda #40
  sta print_count
  jsr hiprint

  ; line 3: "sd2snes menu ROM loaded OK" at row 14
  lda #14
  sta print_y
  lda #4
  sta print_x
  lda #emu_str3 >> 16
  sta print_bank
  ldx #emu_str3 & $ffff
  stx print_src
  stz print_pal
  lda #40
  sta print_count
  jsr hiprint

  ; line 4: "Edit palette.a65 for colors" at row 17
  lda #17
  sta print_y
  lda #4
  sta print_x
  lda #emu_str4 >> 16
  sta print_bank
  ldx #emu_str4 & $ffff
  stx print_src
  stz print_pal
  lda #40
  sta print_count
  jsr hiprint

  ; line 5: "Edit main.a65 for this text" at row 19
  lda #19
  sta print_y
  lda #4
  sta print_x
  lda #emu_str5 >> 16
  sta print_bank
  ldx #emu_str5 & $ffff
  stx print_src
  stz print_pal
  lda #40
  sta print_count
  jsr hiprint

  ; Wait one NMI frame for DMA to transfer text to VRAM
- lda isr_done
  lsr
  bcc -
  stz isr_done
  rts


; =============================================
; snes_init - Initialize all PPU and CPU I/O registers
; Requires: DBR = $00
; =============================================
snes_init
  .databank 0
  sep #$20
  .as
  rep #$10
  .xl

  stz $4200            ; disable NMI, IRQ, auto joypad
  lda #$ff
  sta $4201            ; I/O port = all high
  stz $4202            ; multiplicand
  stz $4203            ; multiplier
  stz $4204            ; dividend low
  stz $4205            ; dividend high
  stz $4206            ; divisor
  stz $4207            ; H-count timer low
  stz $4208            ; H-count timer high
  stz $4209            ; V-count timer low
  stz $420a            ; V-count timer high
  stz $420b            ; DMA enable = none
  stz $420c            ; HDMA enable = none

  ; Force blank ON (screen off while we set up)
  lda #$8f
  sta $2100            ; INIDISP = force blank + max brightness

  ; OBJ settings (match snescom: 8x8+16x16, name=0, base=3)
  lda #$03
  sta $2101
  stz $2102
  stz $2103

  ; BG mode
  stz $2105
  stz $2106

  ; BG tilemap addresses (will be set properly in video_init)
  stz $2107
  stz $2108
  stz $2109
  stz $210a

  ; BG character base addresses
  stz $210b
  stz $210c

  ; Scroll registers
  stz $210d
  stz $210d
  stz $210e
  stz $210e
  stz $210f
  stz $210f
  lda #$05             ; BG2 V-scroll initial (match snescom)
  sta $2110
  stz $2110
  stz $2111
  stz $2111
  stz $2112
  stz $2112
  stz $2113
  stz $2113
  stz $2114
  stz $2114

  ; VRAM address mode
  lda #$80
  sta $2115            ; VMAIN: increment on high byte write, step +1

  ; Zero VRAM address
  stz $2116
  stz $2117

  ; Mode 7 matrix (identity)
  stz $211a
  stz $211b
  lda #$01
  sta $211b
  stz $211c
  stz $211c
  stz $211d
  stz $211d
  stz $211e
  sta $211e
  stz $211f
  stz $211f
  stz $2120
  stz $2120

  ; CGRAM address
  stz $2121

  ; Window settings
  stz $2123
  stz $2124
  stz $2125
  stz $2126
  stz $2127
  stz $2128
  stz $2129
  stz $212a
  stz $212b

  ; Main/sub screen designation
  stz $212c
  stz $212d
  stz $212e
  stz $212f

  ; Color math
  lda #$30
  sta $2130
  stz $2131
  lda #$e0
  sta $2132            ; fixed color = black
  stz $2133            ; SETINI = normal

  rts


; =============================================
; waitblank - Wait for VBlank (poll $4212)
; Requires: DBR = $00
; =============================================
waitblank
  php
  phb
  sep #$30
  .as
  .xs
  lda #$00
  pha
  plb
  .databank 0
  ; Wait for NOT in VBlank first
- lda $4212
  bmi -
  ; Now wait for VBlank to start
- lda $4212
  bpl -
  plb
  plp
  rts


; =============================================
; clear_wram - Fill all WRAM with $55 using DMA
; Fills $7E:0000-$7E:1FEF (spares stack at $1FF0+),
; $7E:2000-$7E:FFFF, and bank $7F.
; Uses WRAM port ($2180-$2183) + DMA channel 7.
; Requires: DBR=$00, DMA disabled
; =============================================
clear_wram
  .databank 0
  php
  rep #$10
  .xl
  sep #$20
  .as
  ldx #$0000
  stz $2183              ; WRAM bank = $7E (bit 0 = 0)
  stx $2181              ; WRAM address = $0000
  lda #$55
  sta $2aff              ; fill value source byte
  ldx #$8008
  stx $4370              ; DMA mode: fixed source → $2180
  ldx #$2aff
  stx $4372              ; source address = $2AFF
  stz $4374              ; source bank = $00
  lda #$80
  ; Fill $7E:0000-$7E:1FEF (spare stack at $1FF0+)
  ldx #$1ff0
  stx $4375
  sta $420b
  ; Fill $7E:2000-$7E:FFFF
  ldx #$2000
  stx $2181
  ldx #$e000
  stx $4375
  sta $420b
  ; Fill bank $7F
  ldx #$0000
  stx $4375              ; size 0 = 65536 bytes
  sta $420b
  plp
  rts


; =============================================
; clear_vram - Zero all 64KB of VRAM using DMA
; Requires: DBR = $00, force blank must be on
; =============================================
clear_vram
  .databank 0
  sep #$20
  .as

  lda #$80
  sta $2115            ; VMAIN: increment after high byte write
  stz $2116            ; VMADD low = 0
  stz $2117            ; VMADD high = 0

  ; DMA channel 7: fixed source → VRAM ($2118/$2119)
  DMA7 $09, zero, $18, 0  ; size=0 → 65536 bytes

  rts


; =============================================
; clear_cgram - Zero all 512 bytes of CGRAM
; Requires: DBR = $00, force blank must be on
; =============================================
clear_cgram
  .databank 0
  sep #$20
  .as

  stz $2121            ; CGADD = 0

  ; DMA channel 7: fixed source → CGRAM ($2122)
  DMA7 $08, zero, $22, $0200  ; 512 bytes

  rts


; =============================================
; store_wram_routines - Copy ROM routine images to WRAM
; Uses MVN to bulk-copy 5 routines from ROM bank $C0.
; Requires: DBR=$00
; =============================================
store_wram_routines
  .databank 0
  php
  rep #$30
  .al
  .xl
  phb
  ; Copy wram_routine_src → WRAM_ROUTINE ($7EF000), $80 bytes
  ; 64tass MVN convention: mvn source_bank, dest_bank (opposite of snescom!)
  lda #$007f
  ldx #wram_routine_src & $ffff
  ldy #WRAM_ROUTINE & $ffff
  mvn $c0, $7e
  ; Copy store_blockram_routine_src → WRAM_STORE_BLOCKRAM_ROUTINE ($7EF080), $80 bytes
  lda #$007f
  ldx #store_blockram_routine_src & $ffff
  ldy #WRAM_STORE_BLOCKRAM_ROUTINE & $ffff
  mvn $c0, $7e
  ; Copy fadeloop → WRAM_FADELOOP ($7EF100), $EF bytes
  lda #$00ee
  ldx #fadeloop & $ffff
  ldy #WRAM_FADELOOP & $ffff
  mvn $c0, $7e
  ; Copy wram_wait_mcu_src → WRAM_WAIT_MCU ($7EF200), $0B bytes
  lda #$000a
  ldx #wram_wait_mcu_src & $ffff
  ldy #WRAM_WAIT_MCU & $ffff
  mvn $c0, $7e
  ; Copy wram_load_ultra16_cfg_src → WRAM_LOAD_ULTRA16_CFG ($7EF210), $80 bytes
  lda #$007f
  ldx #wram_load_ultra16_cfg_src & $ffff
  ldy #WRAM_LOAD_ULTRA16_CFG & $ffff
  mvn $c0, $7e
  plb
  .databank 0          ; MVN changed DBR to $7E; plb restores $00
  plp
  rts


; =============================================
; wait_mcu_ready - Poll SNES_CMD for MCU ready ($55)
; Times out after ~65536 iterations (for emulator detection).
; Requires: DBR=$00
; =============================================
wait_mcu_ready
  .databank 0
  php
  sep #$20
  .as
  lda #$00
  sta MCU_CMD            ; clear any pending command
  rep #$10
  .xl
  ldx #$0000             ; timeout counter
- lda SNES_CMD
  cmp #$55
  beq +
  dex
  bne -                  ; try ~65536 times then give up
+ plp
  rts


; =============================================
; detect_ultra16 - Check for Ultra16 hardware
; Tests $0021C0 register for echo behavior. Writes result
; to ST_IS_U16 ($FF1110) in SRAM so MCU knows reset timing.
; Requires: DBR=$00
; =============================================
detect_ultra16
  .databank 0
  php
  sep #$20
  .as
  lda #$aa
  sta $0021c0
  lda $0021c0
  cmp #$55
  beq detect_ultra16_found
  lda #$00
  sta ST_IS_U16              ; long addr (bank $FF, auto from .databank 0)
  bra detect_ultra16_out
detect_ultra16_found
  lda $0021c2
  sta ST_IS_U16
  jsl WRAM_LOAD_ULTRA16_CFG
  lda $0021c1
  and #$fb
  sta $0021c1
detect_ultra16_out
  lda #$55
  sta $0021c0
  plp
  rts


; =============================================
; detect_satellaview - Check for Satellaview hardware
; Tests $2188 register for echo behavior. Writes result
; to ST_HAS_SATELLAVIEW ($FF1112) in SRAM.
; Requires: DBR=$00
; =============================================
detect_satellaview
  .databank 0
  php
  sep #$20
  .as
  lda #$aa
  sta $2188
  cmp $2188
  bne detect_satellaview_out
  lda #$55
  sta $2188
  cmp $2188
  bne detect_satellaview_out
detect_satellaview_found
  stz $2188
  stz $2189
  stz $218e
  stz $218f
  lda #$01
  sta ST_HAS_SATELLAVIEW     ; long addr (bank $FF)
  plp
  rts
detect_satellaview_out
  lda #$00
  sta ST_HAS_SATELLAVIEW     ; long addr (bank $FF)
  plp
  rts

; =============================================
; backup_wram - Save 8KB of WRAM to SRAM for warm boot restore
; Copies $7E:0000-$7E:1FFF → $FF:2000 (WRAM_BAK)
; =============================================
backup_wram
  php
  rep #$10
  .xl
  sep #$20
  .as
  .databank 0
  ldx #$0000
  stx $2181              ; WRAM source address = $0000
  stz $2183              ; WRAM bank = $7E
  DMA7 $80, WRAM_BAK, $80, $2000
  plp
  rts

; =============================================
; game_handshake - Send load command to MCU, wait for ACK,
; then jump to WRAM routine (FPGA reconfig → fade → game).
; Input: A = command byte (e.g., CMD_LOADROM)
; Requires: DBR=$00
; =============================================
game_handshake
  .databank 0
  .dpage 0
  php
  sep #$20
  .as
  pha                    ; save command byte
  lda #$01
  jsr hide_cursor
  jsr draw_loading_window
  jsr waitblank
  ; Send initial request to MCU
  lda #$00
  sta SNES_CMD
  sta $4200              ; disable NMI
  sei
  pla
  sta MCU_CMD            ; send the command
  ; Wait for ACK/NACK
- lda SNES_CMD
  cmp #$55
  beq +
  cmp #$aa
  beq game_handshake_error
  bra -
+ lda #$55
  sta MCU_CMD
  ; Jump to WRAM routine (FPGA reconfig → fadeloop → game loads)
  jsl WRAM_ROUTINE
  plp
  rts

game_handshake_error
  .databank 0
  ; TODO: display meaningful error message
  jsr pop_window
  plp
  rts


; =============================================
; WRAM routine source images
; These are assembled in ROM (bank $C0) but execute from WRAM/BRAM
; after being MVN-copied by store_wram_routines at boot.
; =============================================

; --- wram_routine_src ---
; Copied to $7EF000. Called via JSL from game_handshake.
; Sends FPGA reconfig command, waits for ACK, installs fadeloop
; in block RAM, then jumps to it.
; DBR=$00 at entry (from caller). All accesses use long addressing.
wram_routine_src
  .databank ?            ; runs from WRAM, DBR unknown at assembly time
  php
  sep #$20
  .as
  rep #$10
  .xl
  ; Acknowledge ready for FPGA reconf
  lda #CMD_FPGA_RECONF
  sta MCU_CMD            ; auto-long from .databank ?
  ; Wait for ACK (reconf done or not necessary)
- lda SNES_CMD           ; auto-long
  cmp #$77
  bne -
  ; Install fadeloop in block RAM after FPGA reconf
  ; (ROM not available after reconfig — must copy from WRAM)
  jsl WRAM_STORE_BLOCKRAM_ROUTINE
  jsl BRAM_ROUTINE
  plp
  rtl

; --- store_blockram_routine_src ---
; Copied to $7EF080. Copies fadeloop from WRAM to block RAM (BRAM).
; Called via JSL from wram_routine_src.
; DBR=$00 at entry (carried from original caller).
store_blockram_routine_src
  .databank ?
  php
  sep #$20
  .as
  rep #$10
  .xl
  ; Write BRA $FE (infinite loop opcode) to infloop WRAM var
  lda #$80
  sta infloop            ; auto-long from .databank ?
  lda #$fe
  sta infloop+1          ; auto-long
  ; Copy fadeloop from WRAM ($7E) to block RAM ($00)
  ; 64tass MVN: mvn source_bank, dest_bank
  rep #$20
  .al
  lda #$00ee
  ldx #WRAM_FADELOOP & $ffff
  ldy #BRAM_ROUTINE & $ffff
  phb
  mvn $7e, $00
  plb
  plp
  rtl

; --- fadeloop ---
; Copied to $7EF100, then copied again to BRAM ($002A10) at runtime.
; Executes from BRAM bank $00. PHK/PLB sets DBR=$00.
; Fades screen to black, fills WRAM, sends CMD_RESET, infinite loops.
fadeloop
  .databank ?            ; initially unknown
  sep #$30
  .as
  .xs
  phk
  plb
  .databank 0            ; now DBR=$00 (executing from BRAM bank $00)
  stz $4200              ; disable NMI
  sei
  sta MCU_CMD            ; A has command byte from caller
  ldx cur_bright         ; current screen brightness
fadeloop_start
  lda $4212
  asl a
  bcs fadeloop_start     ; wait for NOT in VBlank
- lda $4212
  asl a
  bcc -                  ; wait for VBlank start
  dex
  dex
  stx $2100              ; decrease brightness
  bpl fadeloop_start     ; keep fading until brightness < 0
  ; Screen is now dark — force blank
  stz $2126
  stz $212e
  stz $2131
  stz $2130
  lda #$80
  sta $2100              ; force blank on
  stz MCU_CMD            ; clear command (use absolute, MCU_CMD=$2A00)
  stz $420c              ; disable HDMA
  ; DMA fill WRAM banks with $55
  ldx #$00
  rep #$10
  .xl
  stz $2183              ; WRAM bank = $7E (bit 0 = 0)
  stx $2181              ; WRAM address = $0000
  stx $4375              ; transfer size = 0 → 65536 bytes
  lda #$55
  sta $2aff              ; WRAM fill value source byte
  ldx #$8008
  stx $4370              ; DMA mode: fixed source, write to B-bus
  ldx #$2aff
  stx $4372              ; source address = $2AFF
  stz $4374              ; source bank = $00
  lda #$80
  ; Fill bank $7E
  sta $420b
  ; Fill bank $7F
  sta $420b
  ; Reset PPU2 H/V odd/even read flag
  lda $213f
  ; Fix for uninitialized DMA transfers — clear all DMA registers
  rep #$20
  .al
  lda #$ffff
  ldy #$007c
- dey
  dey
  sta $4300, y
  bne -
  ; Write infinite loop (BRA $FE) to high WRAM and jump there
  lda #$fe80              ; $80 = BRA, $FE = -2 (branch to self)
  sta $7fffe0             ; auto-long (bank $7F)
  lda #CMD_RESET
  sta MCU_CMD             ; send reset command to MCU
  jml $7fffe0             ; jump to infinite loop
- bra -                   ; unreachable fallback
fadeloop_end

; --- wram_wait_mcu_src ---
; Copied to $7EF200. Called via JSL from filesel.
; Infinite loop polling SNES_CMD for $55 (MCU ready).
; Never times out — MCU always responds on real hardware.
wram_wait_mcu_src
  .databank ?
  .as
- lda SNES_CMD           ; auto-long from .databank ?
  cmp #$55
  bne -
  rtl

; --- wram_load_ultra16_cfg_src ---
; Copied to $7EF210. Reads Ultra16 configuration register.
wram_load_ultra16_cfg_src
  .databank ?
  .as
  lda $0021c1            ; auto-long
  and #$fe
  sta $0021c1            ; auto-long
  lda $c70000            ; auto-long (Ultra16 config in bank $C7)
  pha
  lda $0021c1            ; auto-long
  ora #$01
  sta $0021c1            ; auto-long
  pla
  sta ST_U16_CFG         ; auto-long
  rtl


; =============================================
; NMI hook binary - installed to BRAM ($2A10) by MCU
; during game loading (snescmd_prepare_nmihook).
; MCU reads nmihook_ptr from $C0FF00 to find this data.
; Extracted from original snescom-built ROM (240 bytes).
; Must be byte-exact: FPGA patches branch offsets at
; hardcoded positions within this block.
; =============================================
nmihook
  .binary "nmihook.bin"


; =============================================
; Include additional source files
; =============================================
.include "anim.a65"
.include "ui.a65"
.include "common.a65"
.include "pad.a65"
.include "filesel.a65"
.include "time.a65"
.include "spc700.a65"
.include "spcplay.a65"
.include "menu.a65"
.include "menudata.a65"
.include "sysinfo.a65"
.include "dma.a65"
.include "font.a65"
.include "palette.a65"
.include "const.a65"
.include "reset.a65"
.include "header.a65"

; =============================================
; Pad ROM to exactly 64KB
; =============================================
.if * < $C10000
  .fill $C10000 - *, $00
.endif
