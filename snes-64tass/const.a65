; const.a65 - HDMA source tables, constants, and strings (64tass)
; These ROM tables are DMA'd to WRAM at boot so HDMA can read
; from stable RAM even when the cartridge bus is unavailable.

zero            .word 0

; =============================================
; HDMA palette gradient source (channels 1+2)
; Format: scanline_count, low_byte, high_byte (BGR555)
; Terminated by $00
; Initial state = pink gradient (palette 0)
; Animated at runtime by animate_gradient
; =============================================
hdma_pal_src
  ; Full-screen gradient: 10 bands, dark → light = 224 scanlines
  ; Scanline counts: 22,23,22,23,22,22,23,22,23,22 = 224 total
  ; Initial state = palette 0 (warm red/orange)
  .byte 22, $02, $00   ; step 0: R= 2,G=0,B=0
  .byte 23, $25, $00   ; step 1: R= 5,G=1,B=0
  .byte 22, $48, $04   ; step 2: R= 8,G=2,B=1
  .byte 23, $6a, $04   ; step 3: R=10,G=3,B=1
  .byte 22, $8d, $08   ; step 4: R=13,G=4,B=2
  .byte 22, $90, $0c   ; step 5: R=16,G=4,B=3
  .byte 23, $b2, $0c   ; step 6: R=18,G=5,B=3
  .byte 22, $d5, $10   ; step 7: R=21,G=6,B=4
  .byte 23, $f8, $14   ; step 8: R=24,G=7,B=5
  .byte 22, $1a, $15   ; step 9: R=26,G=8,B=5
  .byte $00            ; terminator
hdma_pal_src_end

; =============================================
; Gradient target palettes for animation
; Each palette = 84 bytes: R[28], G[28], B[28]
; Channel values are 0-31 (5-bit BGR555 range)
; Linear interpolation: val[i] = start + round((end-start) * i / 27)
; =============================================

gradient_pal_data

; Palette 0: Left wall — Warm Red/Orange (R-dominant)
; Range: dark (R=2,G=0,B=0) → bright (R=26,G=8,B=5)
gradient_pal_0
  .byte  2,  5,  8, 10, 13, 16, 18, 21, 24, 26   ; R
  .byte  0,  1,  2,  3,  4,  4,  5,  6,  7,  8    ; G
  .byte  0,  0,  1,  1,  2,  3,  3,  4,  5,  5    ; B

; Palette 1: Right wall — Cool Blue/Indigo (B-dominant)
; Range: dark (R=0,G=0,B=2) → bright (R=6,G=5,B=27)
gradient_pal_1
  .byte  0,  1,  1,  2,  3,  3,  4,  5,  5,  6    ; R
  .byte  0,  0,  1,  1,  2,  2,  3,  4,  4,  5    ; G
  .byte  2,  5,  8, 10, 13, 16, 18, 21, 24, 27    ; B

; Palette 2: Top wall — Green/Teal (G-dominant)
; Range: dark (R=0,G=2,B=1) → bright (R=4,G=25,B=13)
gradient_pal_2
  .byte  0,  0,  1,  1,  2,  2,  3,  3,  4,  4    ; R
  .byte  2,  4,  7,  9, 12, 14, 17, 19, 22, 25    ; G
  .byte  1,  2,  3,  5,  6,  7,  9, 10, 12, 13    ; B

; Palette 3: Bottom wall — Gold/Amber (R+G balanced)
; Range: dark (R=2,G=1,B=0) → bright (R=26,G=19,B=3)
gradient_pal_3
  .byte  2,  5,  8, 10, 13, 16, 18, 21, 24, 26    ; R
  .byte  1,  3,  5,  7,  9, 11, 13, 15, 17, 19    ; G
  .byte  0,  0,  0,  1,  1,  1,  2,  2,  2,  3    ; B

; Phase offset table: wall palette index → byte offset into gradient_pal_data
gradient_phase_offsets
  .byte 0, 30, 60, 90

; =============================================
; HDMA CG address source (channel 1)
; Always writes 0 to CGADD so channel 2 targets color 0
; =============================================
hdma_cg_addr_src
  .byte $f0
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $f0
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00, $00, $00, $00, $00, $00, $00, $00
  .byte $00

; =============================================
; HDMA mode switch source (channel 3)
; Switches between Mode 3 (top) and Mode 5 (text area)
; =============================================
hdma_mode_src   .byte 8, $03, $01, $05, $00

; =============================================
; HDMA BG1 horizontal scroll source (channel 4)
; =============================================
hdma_bg1scroll_src
  .byte 8
  .byte $00, $00, $ff, $03
  .byte 127
  .byte $fc, $00, $0d, $00
  .byte 24
  .byte $fc, $00, $0d, $00
  .byte 1
  .byte $fc, $00, $0f, $00
  .byte $00

; =============================================
; HDMA BG2 vertical scroll source (channel 0)
; =============================================
hdma_bg2scroll_src
  .byte 8
  .byte $ff, $03
  .byte 127
  .byte $0d, $00
  .byte 24
  .byte $0d, $00
  .byte 1
  .byte $0f, $00
  .byte 0

; =============================================
; HDMA color math source (channel 5)
; Controls selection bar highlight via COLDATA
; =============================================
hdma_math_src
  .byte 1             ; these are filled in...
  .byte $00, $3f      ; R=31 (COLDATA: red channel, intensity 31)
  .byte 1             ; ...to move the color bar
  .byte $00, $48      ; G=8  (COLDATA: green channel, intensity 8)
  .byte 1
  .byte $33, $90      ; sub half, B=16 (COLDATA: blue channel, intensity 16)
  .byte 7
  .byte $33, $40      ; sub half, G=0
  .byte 1
  .byte $73, $00
  .byte 1
  .byte $00, $e0
  .byte 0

hdma_bar_color_src
  .byte $3f, $48, $90, $40  ; normal color (pink: R=31,G=8,B=16)
  .byte $3f, $4c, $8c, $40  ; highlight color (warm pink: R=31,G=12,B=12)

; =============================================
; Title strings (spaced for "larger" feel)
; =============================================
title_str1  .text "S A T E L L A V I E W"
            .byte 0
title_str2  .text "revival project"
            .byte 0
title_str3  .text "by DavidAF"
            .byte 0

; =============================================
; Emulator mode strings
; =============================================
emu_str1  .text "WE HAVE BREACHED THE PERIMITER"
          .byte 0
emu_str2  .text "No MCU detected"
          .byte 0
emu_str3  .text "sd2snes menu ROM loaded OK"
          .byte 0
emu_str4  .text "Edit palette.a65 for colors"
          .byte 0
emu_str5  .text "Edit main.a65 for this text"
          .byte 0

; =============================================
; Window frame characters and UI data
; =============================================
space64
  .byte $20, $20, $20, $20, $20, $20, $20, $20
  .byte $20, $20, $20, $20, $20, $20, $20, $20
  .byte $20, $20, $20, $20, $20, $20, $20, $20
  .byte $20, $20, $20, $20, $20, $20, $20, $20
  .byte $20, $20, $20, $20, $20, $20, $20, $20
  .byte $20, $20, $20, $20, $20, $20, $20, $20
  .byte $20, $20, $20, $20, $20, $20, $20, $20
  .byte $20, $20, $20, $20, $20, $20, $20, $20
  .byte $00

text_dirmark  .text " <dir>"
              .byte 0
window_nw     .byte 20
window_ne     .byte 21
window_sw     .byte 22
window_se     .byte 23
window_nh     .byte 24
window_sh     .byte 25
window_wv     .byte 26
window_ev     .byte 27
window_tl     .byte 28
window_tr     .byte 29

text_loading  .text "Loading"
              .byte 127, 128
              .text "                        "
              .byte 0

loading_win_x .byte 2
loading_win_y .byte 28
loading_win_w .byte 34
loading_win_h .byte 1

; Filesel UI strings
text_statusbar_keys .text "A:Select B:Back X:Menu Y:Context"
                    .byte 0
text_last           .text "Recent games"
                    .byte 0
text_favorite       .text "Favorite games"
                    .byte 0

; Window dimensions for "last game" / favorites popup
last_win_x  .byte 2
last_win_y  .byte 12
last_win_w  .byte 60

; =============================================
; Ball sprite tile data (8x8, 4bpp = 32 bytes)
; Simple filled circle pattern
; =============================================
ball_tile
  ; Planes 0+1 interleaved (rows 0-7)
  ; Pattern: ..####.. = $3C, .######. = $7E, ######## = $FF
  .byte $3c, $3c   ; row 0: ..####..
  .byte $7e, $7e   ; row 1: .######.
  .byte $ff, $ff   ; row 2: ########
  .byte $ff, $ff   ; row 3: ########
  .byte $ff, $ff   ; row 4: ########
  .byte $ff, $ff   ; row 5: ########
  .byte $7e, $7e   ; row 6: .######.
  .byte $3c, $3c   ; row 7: ..####..
  ; Planes 2+3 interleaved (rows 0-7)
  .byte $3c, $3c   ; row 0
  .byte $7e, $7e   ; row 1
  .byte $ff, $ff   ; row 2
  .byte $ff, $ff   ; row 3
  .byte $ff, $ff   ; row 4
  .byte $ff, $ff   ; row 5
  .byte $7e, $7e   ; row 6
  .byte $3c, $3c   ; row 7
ball_tile_end
