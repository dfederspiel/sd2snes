; data.i65 - WRAM variable address constants for 64tass
;
; All variables live in WRAM (bank $7E). We use 16-bit addresses
; because all variables are in the $0000-$02FF range, which is
; within the bank $00 WRAM mirror ($00:0000-$1FFF = $7E:0000-$1FFF).
;
; This means the same address works regardless of .databank:
;   .databank $7e → sta $0020 accesses $7E:0020 (direct)
;   .databank 0   → sta $0020 accesses $00:0020 (WRAM mirror)
;
; For indirect long [ptr], the CPU reads from DP+offset in bank $00,
; which also hits the WRAM mirror. So 16-bit addresses Just Work.
;
; For DMA to/from WRAM above $1FFF (tile buffers), use $7E0000+addr.

; =============================================
; Print system ($0000-$001F)
; =============================================
print_x     = $0000   ; .word - x coordinate (tile column)
print_y     = $0002   ; .word - y coordinate (tile row)
print_src   = $0004   ; .word - source string address (16-bit)
print_bank  = $0006   ; .byte - source string bank
print_pal   = $0007   ; .word - palette number for text
print_temp  = $0009   ; .word - work variable
print_ptr   = $000B   ; 3 bytes - read pointer (long)
print_count = $000E   ; .word - max chars to print
print_done  = $0010   ; .word - chars actually printed
print_over  = $0012   ; .byte - was string truncated?

; =============================================
; State flags ($0020-$002F)
; =============================================
isr_done           = $0020  ; .byte - NMI completion flag
bar_xl             = $0021  ; .byte - logical X of select bar
bar_yl             = $0022  ; .byte - logical Y of select bar
bar_x              = $0023  ; .byte - pixel X of select bar
bar_y              = $0024  ; .byte - pixel Y of select bar
bar_w              = $0025  ; .byte - bar width (pixels)
bar_wl             = $0026  ; .byte - bar width (logical)
screen_dma_disable = $0027  ; .word - skip tile DMA when nonzero

; =============================================
; Brightness ($0030-$003F)
; =============================================
tgt_bright   = $0030  ; .byte - target brightness (NMI fades toward)
cur_bright   = $0031  ; .byte - current brightness
bright_limit = $0032  ; .byte - max brightness from config
fade_speed   = $0033  ; .byte - frames between fade steps
fade_count   = $0034  ; .byte - current fade frame counter

; =============================================
; Joypad ($0040-$0057)
; =============================================
pad1mem    = $0040  ; .word - joypad current state
pad1trig   = $0042  ; .word - joypad edge detection (newly pressed)
pad1delay  = $0044  ; .word - key repeat delay counter
pad_b      = $0046  ; .byte - B button (edge-triggered)
pad_y      = $0047  ; .byte - Y button
pad_select = $0048  ; .byte - Select button
pad_start  = $0049  ; .byte - Start button
pad_up     = $004A  ; .byte - D-pad up
pad_down   = $004B  ; .byte - D-pad down
pad_left   = $004C  ; .byte - D-pad left
pad_right  = $004D  ; .byte - D-pad right
pad_a      = $004E  ; .byte - A button
pad_x      = $004F  ; .byte - X button
pad_l      = $0050  ; .byte - L shoulder
pad_r      = $0051  ; .byte - R shoulder

; =============================================
; Animation state ($0058-$006F)
; =============================================
anim_frame   = $0058  ; .byte - interpolation progress (0-127)
anim_speed   = $0059  ; .byte - frames to skip between updates
anim_timer   = $005A  ; .byte - frame skip counter
anim_phase   = $005B  ; .byte - current palette transition (0-2)
anim_src_idx = $005C  ; .word - ROM offset of "from" palette
anim_dst_idx = $005E  ; .word - ROM offset of "to" palette
anim_src_ptr = $0060  ; 3 bytes - long pointer to src palette in ROM
anim_dst_ptr = $0063  ; 3 bytes - long pointer to dst palette in ROM
anim_temp    = $0066  ; 4 bytes - temp workspace for interpolation
staging_ptr  = $006A  ; 2 bytes - pointer to inactive hdma_pal buffer
hdma_pal_flip = $006C ; .byte - 0: HDMA reads A, write B; 1: HDMA reads B, write A

; =============================================
; Ball sprite state ($0070-$007F)
; =============================================
ball_x     = $0070  ; .byte - X position (pixels)
ball_y     = $0071  ; .byte - Y position (pixels)
ball_vx    = $0072  ; .byte - X velocity (signed, pixels/frame)
ball_vy    = $0073  ; .byte - Y velocity (signed, pixels/frame)
bounce_wall = $0074 ; .byte - which wall was hit (0=none, 1-4=wall)

; Screen bounds for ball (8x8 sprite)
BALL_MIN_X = 0
BALL_MAX_X = 248    ; 256 - 8
BALL_MIN_Y = 1
BALL_MAX_Y = 215    ; 224 - 8 - 1

; Wall identifiers for bounce_wall
WALL_NONE   = 0
WALL_LEFT   = 1
WALL_RIGHT  = 2
WALL_TOP    = 3
WALL_BOTTOM = 4

; =============================================
; Animation constants
; =============================================
NUM_GRADIENT_STEPS = 10
NUM_PALETTES       = 4
PALETTE_SIZE       = 30   ; 10 R + 10 G + 10 B per palette

; =============================================
; HDMA tables ($0100-$02FF, double-buffer at $0300)
; Copied from ROM source tables at boot via DMA to WRAM port.
; HDMA reads from these WRAM copies (bank $00 mirror = bank $7E).
;
; hdma_pal is double-buffered to prevent HDMA read tearing:
;   Buffer A = hdma_pal ($0100), Buffer B = hdma_pal_back ($0300)
;   animate_gradient writes to the inactive buffer, then updates
;   HDMA ch2's source pointer ($4322). HDMA re-reads the pointer
;   at the next V-Blank init, making the swap atomic.
; =============================================
hdma_pal              = $0100  ; 128 bytes - gradient BGR555 colors (buffer A)
hdma_pal_back         = $0300  ; 128 bytes - gradient BGR555 colors (buffer B)
hdma_cg_addr          = $0180  ; 227 bytes - CGRAM address (all zeros)
hdma_mode             = $0263  ; 5 bytes - BG mode switching
hdma_bg1scroll        = $0268  ; 21 bytes - BG1 horizontal scroll
hdma_bg2scroll        = $027D  ; 13 bytes - BG2 vertical scroll
hdma_math             = $028A  ; 6 bytes - color math initial
hdma_math_upperborder = $0290  ; 3 bytes - selection bar upper border
hdma_math_selection   = $0293  ; 3 bytes - selection bar highlight
hdma_math_lowerborder = $0296  ; 10 bytes - selection bar lower border
