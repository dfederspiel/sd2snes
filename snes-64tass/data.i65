; data.i65 - WRAM variable address constants for 64tass
;
; All variables live in WRAM (bank $7E). We use 16-bit addresses
; because all variables are in the $0000-$02FF range, which is
; within the bank $00 WRAM mirror ($00:0000-$1FFF = $7E:0000-$1FFF).
;
; This means the same address works regardless of .databank:
;   .databank $7e → sta $0020 accesses $7E:0020 (direct)
;   .databank 0   → sta $0020 accesses $00:0020 (WRAM mirror)
;
; For indirect long [ptr], the CPU reads from DP+offset in bank $00,
; which also hits the WRAM mirror. So 16-bit addresses Just Work.
;
; For DMA to/from WRAM above $1FFF (tile buffers), use $7E0000+addr.

; =============================================
; Print system ($0000-$001F)
; =============================================
print_x     = $0000   ; .word - x coordinate (tile column)
print_y     = $0002   ; .word - y coordinate (tile row)
print_src   = $0004   ; .word - source string address (16-bit)
print_bank  = $0006   ; .byte - source string bank
print_pal   = $0007   ; .word - palette number for text
print_temp  = $0009   ; .word - work variable
print_ptr   = $000B   ; 3 bytes - read pointer (long)
print_count = $000E   ; .word - max chars to print
print_done  = $0010   ; .word - chars actually printed
print_over  = $0012   ; .byte - was string truncated?

; =============================================
; State flags ($0020-$002F)
; =============================================
isr_done           = $0020  ; .byte - NMI completion flag
bar_xl             = $0021  ; .byte - logical X of select bar
bar_yl             = $0022  ; .byte - logical Y of select bar
bar_x              = $0023  ; .byte - pixel X of select bar
bar_y              = $0024  ; .byte - pixel Y of select bar
bar_w              = $0025  ; .byte - bar width (pixels)
bar_wl             = $0026  ; .byte - bar width (logical)
screen_dma_disable = $0027  ; .word - skip tile DMA when nonzero

; =============================================
; Brightness ($0030-$003F)
; =============================================
tgt_bright   = $0030  ; .byte - target brightness (NMI fades toward)
cur_bright   = $0031  ; .byte - current brightness
bright_limit = $0032  ; .byte - max brightness from config
fade_speed   = $0033  ; .byte - frames between fade steps
fade_count   = $0034  ; .byte - current fade frame counter

; =============================================
; Joypad ($0040-$0057)
; =============================================
pad1mem    = $0040  ; .word - joypad current state
pad1trig   = $0042  ; .word - joypad edge detection (newly pressed)
pad1delay  = $0044  ; .word - key repeat delay counter
pad_b      = $0046  ; .byte - B button (edge-triggered)
pad_y      = $0047  ; .byte - Y button
pad_select = $0048  ; .byte - Select button
pad_start  = $0049  ; .byte - Start button
pad_up     = $004A  ; .byte - D-pad up
pad_down   = $004B  ; .byte - D-pad down
pad_left   = $004C  ; .byte - D-pad left
pad_right  = $004D  ; .byte - D-pad right
pad_a      = $004E  ; .byte - A button
pad_x      = $004F  ; .byte - X button
pad_l      = $0050  ; .byte - L shoulder
pad_r      = $0051  ; .byte - R shoulder

; =============================================
; Animation state ($0058-$006F)
; =============================================
anim_frame   = $0058  ; .byte - interpolation progress (0-127)
anim_speed   = $0059  ; .byte - frames to skip between updates
anim_timer   = $005A  ; .byte - frame skip counter
anim_phase   = $005B  ; .byte - current palette transition (0-2)
anim_src_idx = $005C  ; .word - ROM offset of "from" palette
anim_dst_idx = $005E  ; .word - ROM offset of "to" palette
anim_src_ptr = $0060  ; 3 bytes - long pointer to src palette in ROM
anim_dst_ptr = $0063  ; 3 bytes - long pointer to dst palette in ROM
anim_temp    = $0066  ; 4 bytes - temp workspace for interpolation
staging_ptr  = $006A  ; 2 bytes - pointer to inactive hdma_pal buffer
hdma_pal_flip = $006C ; .byte - 0: HDMA reads A, write B; 1: HDMA reads B, write A

; =============================================
; Ball sprite state ($0070-$007F)
; =============================================
ball_x     = $0070  ; .byte - X position (pixels)
ball_y     = $0071  ; .byte - Y position (pixels)
ball_vx    = $0072  ; .byte - X velocity (signed, pixels/frame)
ball_vy    = $0073  ; .byte - Y velocity (signed, pixels/frame)
bounce_wall = $0074 ; .byte - which wall was hit (0=none, 1-4=wall)

; Screen bounds for ball (8x8 sprite)
BALL_MIN_X = 0
BALL_MAX_X = 248    ; 256 - 8
BALL_MIN_Y = 1
BALL_MAX_Y = 215    ; 224 - 8 - 1

; Wall identifiers for bounce_wall
WALL_NONE   = 0
WALL_LEFT   = 1
WALL_RIGHT  = 2
WALL_TOP    = 3
WALL_BOTTOM = 4

; =============================================
; Animation constants
; =============================================
NUM_GRADIENT_STEPS = 10
NUM_PALETTES       = 4
PALETTE_SIZE       = 30   ; 10 R + 10 G + 10 B per palette

; =============================================
; Window system ($0075-$00C1)
; =============================================
window_x          = $0075  ; .byte - window X position (tile column)
window_y          = $0076  ; .byte - window Y position (tile row)
window_w          = $0077  ; .byte - window width (tiles)
window_h          = $0078  ; .byte - window height (tiles)
window_tmp        = $0079  ; .word - work variable
window_tbank      = $007B  ; .byte - window title string bank
window_taddr      = $007C  ; .word - window title string address
window_stack_head = $007E  ; .word - window stack head pointer
stringbuf         = $0080  ; 66 bytes - string buffer for window rendering

; =============================================
; List/menu selector ($00C2-$00C9)
; =============================================
listsel_sel        = $00C2  ; .byte - current selection index
listsel_step       = $00C3  ; .byte - step size
listsel_max        = $00C4  ; .byte - maximum selection value
listsel_pickbutton = $00C5  ; .byte - button used to pick
listsel_dirty      = $00C6  ; .byte - needs redraw
listsel_backup     = $00C7  ; .byte - backup of selection
listdisp           = $00C8  ; .word - number of displayable list entries

; =============================================
; File selector state ($00CA-$00F2)
; =============================================
dirptr_addr       = $00CA  ; .word - current dir entry address
dirptr_bank       = $00CC  ; .word - current dir entry bank
dirstart_addr     = $00CE  ; .word - start of visible dir window address
dirstart_bank     = $00D0  ; .word - start of visible dir window bank
dirend_addr       = $00D2  ; .word - end of dir listing address
dirend_bank       = $00D4  ; .word - end of dir listing bank
dirend_idx        = $00D6  ; .word - end of dir listing index
dirptr_idx        = $00D8  ; .word - current dir entry index
dirent_addr       = $00DA  ; .word - address of current dirent
dirent_bank       = $00DC  ; .word - bank of current dirent
dirent_type       = $00DE  ; .byte - type of current dirent
dirend_onscreen   = $00DF  ; .byte - is end of dir visible?
dirlog_idx        = $00E0  ; 3 bytes - logical index long pointer
direntry_fits_idx = $00E3  ; .word - entry fits index
longptr           = $00E5  ; 3 bytes - general purpose long pointer
filesel_state     = $00E8  ; .byte - menu state (0=file select)
filesel_dirty     = $00E9  ; .byte - needs redraw
filesel_sel       = $00EA  ; .word - selected item number
cursor_x          = $00EC  ; .byte - current cursor position (x)
cursor_y          = $00ED  ; .byte - current cursor position (y)
fd_addr           = $00EE  ; .word - file descriptor address
fd_bank           = $00F0  ; .byte - file descriptor bank
fd_fnoff          = $00F1  ; .word - filename offset in file descriptor

; =============================================
; HDMA tables ($0100-$02FF, double-buffer at $0300)
; Copied from ROM source tables at boot via DMA to WRAM port.
; HDMA reads from these WRAM copies (bank $00 mirror = bank $7E).
;
; hdma_pal is double-buffered to prevent HDMA read tearing:
;   Buffer A = hdma_pal ($0100), Buffer B = hdma_pal_back ($0300)
;   animate_gradient writes to the inactive buffer, then updates
;   HDMA ch2's source pointer ($4322). HDMA re-reads the pointer
;   at the next V-Blank init, making the swap atomic.
; =============================================
hdma_pal              = $0100  ; 128 bytes - gradient BGR555 colors (buffer A)
hdma_pal_back         = $0300  ; 128 bytes - gradient BGR555 colors (buffer B)
hdma_cg_addr          = $0180  ; 227 bytes - CGRAM address (all zeros)
hdma_mode             = $0263  ; 5 bytes - BG mode switching
hdma_bg1scroll        = $0268  ; 21 bytes - BG1 horizontal scroll
hdma_bg2scroll        = $027D  ; 13 bytes - BG2 vertical scroll
hdma_math             = $028A  ; 6 bytes - color math initial
hdma_math_upperborder = $0290  ; 3 bytes - selection bar upper border
hdma_math_selection   = $0293  ; 3 bytes - selection bar highlight
hdma_math_lowerborder = $0296  ; 10 bytes - selection bar lower border
